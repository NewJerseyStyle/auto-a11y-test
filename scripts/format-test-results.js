import fs from 'fs';
import path from 'path';

/**
 * Formats test results for GitHub PR comment
 * @param {Object} results - Test results object
 * @returns {string} Formatted markdown string
 */
export function formatTestResults(results) {
  const { passed, failed, skipped, duration, tests } = results;
  const total = passed + failed + skipped;
  const passRate = total > 0 ? ((passed / total) * 100).toFixed(1) : 0;
  
  let status = '‚úÖ';
  let statusText = 'PASSED';
  if (failed > 0) {
    status = '‚ùå';
    statusText = 'FAILED';
  } else if (passed === 0 && skipped > 0) {
    status = '‚è≠Ô∏è';
    statusText = 'SKIPPED';
  }
  
  let markdown = `## ${status} AI Accessibility Test Results\n\n`;
  markdown += `**Status:** ${statusText}\n`;
  markdown += `**Pass Rate:** ${passRate}%\n`;
  markdown += `**Duration:** ${duration}ms\n\n`;
  
  // Summary table
  markdown += `### Summary\n\n`;
  markdown += `| Metric | Count |\n`;
  markdown += `|--------|-------|\n`;
  markdown += `| ‚úÖ Passed | ${passed} |\n`;
  markdown += `| ‚ùå Failed | ${failed} |\n`;
  markdown += `| ‚è≠Ô∏è Skipped | ${skipped} |\n`;
  markdown += `| üìä Total | ${total} |\n\n`;
  
  // Failed tests details
  if (failed > 0 && tests) {
    markdown += `### ‚ùå Failed Tests\n\n`;
    const failedTests = tests.filter(t => t.status === 'failed');
    
    failedTests.forEach((test, index) => {
      markdown += `<details>\n`;
      markdown += `<summary>${index + 1}. ${test.name}</summary>\n\n`;
      markdown += `**File:** \`${test.file}\`\n`;
      markdown += `**Line:** ${test.line}\n`;
      markdown += `**Duration:** ${test.duration}ms\n\n`;
      
      if (test.error) {
        markdown += `**Error:**\n`;
        markdown += `\`\`\`\n${test.error}\n\`\`\`\n`;
      }
      
      if (test.goals) {
        markdown += `**Test Goals:**\n`;
        test.goals.forEach(goal => {
          const goalStatus = goal.achieved ? '‚úÖ' : '‚ùå';
          markdown += `- ${goalStatus} ${goal.description}\n`;
        });
      }
      
      markdown += `\n</details>\n\n`;
    });
  }
  
  // Passed tests summary
  if (passed > 0 && tests) {
    markdown += `### ‚úÖ Passed Tests\n\n`;
    const passedTests = tests.filter(t => t.status === 'passed');
    
    markdown += `<details>\n`;
    markdown += `<summary>View ${passed} passed tests</summary>\n\n`;
    
    passedTests.forEach((test, index) => {
      markdown += `${index + 1}. ‚úÖ ${test.name}\n`;
      if (test.goals) {
        test.goals.forEach(goal => {
          if (goal.achieved) {
            markdown += `   - ${goal.description}\n`;
          }
        });
      }
    });
    
    markdown += `\n</details>\n\n`;
  }
  
  // Accessibility findings
  if (results.accessibilityIssues && results.accessibilityIssues.length > 0) {
    markdown += `### ‚ö†Ô∏è Accessibility Issues Found\n\n`;
    markdown += `| Severity | Issue | Location | WCAG Criterion |\n`;
    markdown += `|----------|-------|----------|----------------|\n`;
    
    results.accessibilityIssues.forEach(issue => {
      const severityIcon = {
        'critical': 'üî¥',
        'serious': 'üü†',
        'moderate': 'üü°',
        'minor': 'üîµ'
      }[issue.severity] || '‚ö™';
      
      markdown += `| ${severityIcon} ${issue.severity} | ${issue.description} | ${issue.location} | ${issue.wcag || 'N/A'} |\n`;
    });
    
    markdown += `\n`;
  }
  
  // Test coverage information
  if (results.coverage) {
    markdown += `### üìä Test Coverage\n\n`;
    markdown += `- **Pages Tested:** ${results.coverage.pages}\n`;
    markdown += `- **Elements Interacted:** ${results.coverage.elements}\n`;
    markdown += `- **Navigation Paths:** ${results.coverage.paths}\n`;
    markdown += `- **Screen Reader Commands Used:** ${results.coverage.commands}\n\n`;
  }
  
  // Footer with run information
  markdown += `---\n`;
  markdown += `*ü§ñ Generated by [AI Website ScreenReader Navigation Tester](https://github.com/NewJerseyStyle/AI-Website-ScreenReader-Navigation-Tester)*\n`;
  markdown += `*Run ID: ${results.runId || 'N/A'} | Commit: ${results.commit || 'N/A'}*\n`;
  
  return markdown;
}

/**
 * Parse Playwright test results from JSON report
 * @param {string} reportPath - Path to the Playwright JSON report
 * @returns {Object} Parsed results
 */
export function parsePlaywrightReport(reportPath) {
  try {
    const report = JSON.parse(fs.readFileSync(reportPath, 'utf-8'));
    
    const results = {
      passed: 0,
      failed: 0,
      skipped: 0,
      duration: 0,
      tests: [],
      accessibilityIssues: [],
      coverage: {
        pages: 0,
        elements: 0,
        paths: 0,
        commands: 0
      }
    };
    
    // Parse test results
    report.suites?.forEach(suite => {
      suite.specs?.forEach(spec => {
        spec.tests?.forEach(test => {
          const testResult = {
            name: spec.title,
            file: spec.file,
            line: spec.line,
            status: test.status,
            duration: test.duration,
            error: test.error?.message,
            goals: []
          };
          
          // Extract goals from test annotations or title
          if (spec.title.includes('navigate')) {
            testResult.goals.push({
              description: 'Navigate to find secret information',
              achieved: test.status === 'passed'
            });
          }
          
          if (spec.title.includes('accessibility')) {
            testResult.goals.push({
              description: 'Validate accessibility attributes',
              achieved: test.status === 'passed'
            });
          }
          
          results.tests.push(testResult);
          
          if (test.status === 'passed') results.passed++;
          else if (test.status === 'failed') results.failed++;
          else if (test.status === 'skipped') results.skipped++;
          
          results.duration += test.duration || 0;
        });
      });
    });
    
    // Extract accessibility issues from stdout/stderr
    if (report.errors) {
      report.errors.forEach(error => {
        if (error.message?.includes('aria') || error.message?.includes('accessibility')) {
          results.accessibilityIssues.push({
            severity: 'serious',
            description: error.message,
            location: error.location || 'Unknown',
            wcag: extractWCAGCriterion(error.message)
          });
        }
      });
    }
    
    return results;
  } catch (error) {
    console.error('Error parsing Playwright report:', error);
    return null;
  }
}

/**
 * Extract WCAG criterion from error message
 * @param {string} message - Error message
 * @returns {string} WCAG criterion or null
 */
function extractWCAGCriterion(message) {
  const wcagPattern = /(\d+\.\d+\.\d+)/;
  const match = message.match(wcagPattern);
  return match ? `WCAG ${match[1]}` : null;
}

// CLI usage
if (process.argv[2]) {
  const reportPath = process.argv[2];
  const results = parsePlaywrightReport(reportPath);
  if (results) {
    const markdown = formatTestResults(results);
    console.log(markdown);
  }
}